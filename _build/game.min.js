(function(){
    states = {};

//--------keyboard input--------------
Key = {

    _pressed: {},
    _released: {},

    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    SPACE: 32,
    ONE: 49,
    TWO: 50,
    THREE: 51,
    FOUR: 52,
    a: 65,
    c: 67,
    w: 87,
    s: 83,
    d: 68,
    z: 90,
    x: 88,
    f: 70,
    p: 80,
    r: 82,

    isDown(keyCode) {
        return this._pressed[keyCode];
    },

    justReleased(keyCode) {
        return this._released[keyCode];
    },

    onKeydown(event) {
        this._pressed[event.keyCode] = true;
    },

    onKeyup(event) {
        this._released[event.keyCode] = true;
        delete this._pressed[event.keyCode];

    },

    update() {
        this._released = {};
    }
};

function playSound(buffer, playbackRate = 1, pan = 0, volume = .5, loop = false) {

    var source = audioCtx.createBufferSource();
    var gainNode = audioCtx.createGain();
    var panNode = audioCtx.createStereoPanner();
  
    source.buffer = buffer;
    source.connect(panNode);
    panNode.connect(gainNode);
    gainNode.connect(audioMaster);
  
    source.playbackRate.value = playbackRate;
    source.loop = loop;
    gainNode.gain.value = volume;
    panNode.pan.value = pan;
    source.start();
    return {volume: gainNode, sound: source};

}

/** Seedable psuedo-random number generator class. */
class PRNG {
    /**
     * Create a pseudo-random number generator. The seed must be an integer.
     *
     * Uses the Lehmer / Park-Miller PRNG
     * https://en.wikipedia.org/wiki/Lehmer_random_number_generator
     *
     *  Utilizes MINSTD parameters where:
     *  n = 2^31 âˆ’ 1 = 2,147,483,647 (a Mersenne prime)
     *  g = 7^5 = 16,807 (a primitive root modulo)
     */
    constructor (seed) {
      // Verify that seed is an integer
      if (seed % 1 === 0) {
        // Initialize seed with a modulo by n
        this.seed = seed % 2147483647
        if (this.seed <= 0) {
          // If seed is negative or zero, add n
          this.seed += 2147483646
        }
      } else {
        throw new Error('Seed value must be an integer.')
      }
    }
  
    /** Return a pseudo-random value between 1 and n */
    next () {
      // x_k+1 = (g * x_k) % n
      return this.seed = this.seed * 16807 % 2147483647
    }
  
    /** Return a pseudo-random floating point number in range [0, 1] */
    nextFloat () {
      // We know that result of next() will be 1 to 2147483646 (inclusive)
      return (this.next() - 1) / 2147483646
    }
  
    /** Return pseudo-random int between 0 and the specified max */
    nextBoundedInt(min, max) {
      return Math.floor(this.nextFloat() * (max - min) + min)
    }
  }

function inView(x,y, viewpad = 64){
return(x >= 0-viewpad && x <= viewW+viewpad && y >=0-viewpad && y <= viewH+viewpad);
}
function lineLine(x1, y1, x2, y2, x3, y3, x4, y4){
    let uA = ((x4-x3)*(y1-y3) - (y4-y3)*(x1-x3)) / ((y4-y3)*(x2-x1) - (x4-x3)*(y2-y1));
    let uB = ((x2-x1)*(y1-y3) - (y2-y1)*(x1-x3)) / ((y4-y3)*(x2-x1) - (x4-x3)*(y2-y1));

    //if uA and uB are between 0 and 1, lines are colliding
    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {

        let intX = x1 + (uA * (x2-x1));
        let intY = y1 + (uA * (y2-y1));
        
        return [intX, intY];
        //return true;
      }else return false;
}

function lineBox(x1, y1, x2, y2, rx, ry, rw, rh){
    let left =   lineLine(x1,y1,x2,y2, rx,ry,rx, ry+rh);
    let right =  lineLine(x1,y1,x2,y2, rx+rw,ry, rx+rw,ry+rh);
    let top =    lineLine(x1,y1,x2,y2, rx,ry, rx+rw,ry);
    let bottom = lineLine(x1,y1,x2,y2, rx,ry+rh, rx+rw,ry+rh);

  // if ANY of the above are true, the line
  // has hit the rectangle
  if (left || right || top || bottom) {
      //return true;
    return [left, right, top, bottom];
  }
  return false;
}

boxBox = (a, b) => {
  let aleft = a.x,
      aright = a.x+a.width,
      atop = a.y,
      abottom = a.y+a.height,
      bleft = b.x,
      bright = b.x+b.width,
      btop = b.y,
      bbottom = b.y+b.height;
      
  return !(bleft > aright || 
    bright < aleft || 
    btop > abottom ||
    bbottom < atop);
}
/* -*- mode: javascript; tab-width: 4; indent-tabs-mode: nil; -*-
*
* Copyright (c) 2011-2013 Marcus Geelnard
*
* This software is provided 'as-is', without any express or implied
* warranty. In no event will the authors be held liable for any damages
* arising from the use of this software.
*
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
*
* 1. The origin of this software must not be misrepresented; you must not
*    claim that you wrote the original software. If you use this software
*    in a product, an acknowledgment in the product documentation would be
*    appreciated but is not required.
*
* 2. Altered source versions must be plainly marked as such, and must not be
*    misrepresented as being the original software.
*
* 3. This notice may not be removed or altered from any source
*    distribution.
*
*/

"use strict";

var CPlayer = function() {

    //--------------------------------------------------------------------------
    // Private methods
    //--------------------------------------------------------------------------

    // Oscillators
    var osc_sin = function (value) {
        return Math.sin(value * 6.283184);
    };

    var osc_saw = function (value) {
        return 2 * (value % 1) - 1;
    };

    var osc_square = function (value) {
        return (value % 1) < 0.5 ? 1 : -1;
    };

    var osc_tri = function (value) {
        var v2 = (value % 1) * 4;
        if(v2 < 2) return v2 - 1;
        return 3 - v2;
    };

    var getnotefreq = function (n) {
        // 174.61.. / 44100 = 0.003959503758 (F3)
        return 0.003959503758 * Math.pow(2, (n - 128) / 12);
    };

    var createNote = function (instr, n, rowLen) {
        var osc1 = mOscillators[instr.i[0]],
            o1vol = instr.i[1],
            o1xenv = instr.i[3],
            osc2 = mOscillators[instr.i[4]],
            o2vol = instr.i[5],
            o2xenv = instr.i[8],
            noiseVol = instr.i[9],
            attack = instr.i[10] * instr.i[10] * 4,
            sustain = instr.i[11] * instr.i[11] * 4,
            release = instr.i[12] * instr.i[12] * 4,
            releaseInv = 1 / release,
            arp = instr.i[13],
            arpInterval = rowLen * Math.pow(2, 2 - instr.i[14]);

        var noteBuf = new Int32Array(attack + sustain + release);

        // Re-trig oscillators
        var c1 = 0, c2 = 0;

        // Local variables.
        var j, j2, e, t, rsample, o1t, o2t;

        // Generate one note (attack + sustain + release)
        for (j = 0, j2 = 0; j < attack + sustain + release; j++, j2++) {
            if (j2 >= 0) {
                // Switch arpeggio note.
                arp = (arp >> 8) | ((arp & 255) << 4);
                j2 -= arpInterval;

                // Calculate note frequencies for the oscillators
                o1t = getnotefreq(n + (arp & 15) + instr.i[2] - 128);
                o2t = getnotefreq(n + (arp & 15) + instr.i[6] - 128) * (1 + 0.0008 * instr.i[7]);
            }

            // Envelope
            e = 1;
            if (j < attack) {
                e = j / attack;
            } else if (j >= attack + sustain) {
                e -= (j - attack - sustain) * releaseInv;
            }

            // Oscillator 1
            t = o1t;
            if (o1xenv) {
                t *= e * e;
            }
            c1 += t;
            rsample = osc1(c1) * o1vol;

            // Oscillator 2
            t = o2t;
            if (o2xenv) {
                t *= e * e;
            }
            c2 += t;
            rsample += osc2(c2) * o2vol;

            // Noise oscillator
            if (noiseVol) {
                rsample += (2 * Math.random() - 1) * noiseVol;
            }

            // Add to (mono) channel buffer
            noteBuf[j] = (80 * rsample * e) | 0;
        }

        return noteBuf;
    };


    //--------------------------------------------------------------------------
    // Private members
    //--------------------------------------------------------------------------

    // Array of oscillator functions
    var mOscillators = [
        osc_sin,
        osc_square,
        osc_saw,
        osc_tri
    ];

    // Private variables set up by init()
    var mSong, mLastRow, mCurrentCol, mNumWords, mMixBuf;


    //--------------------------------------------------------------------------
    // Initialization
    //--------------------------------------------------------------------------

    this.init = function (song) {
        // Define the song
        mSong = song;

        // Init iteration state variables
        mLastRow = song.endPattern;
        mCurrentCol = 0;

        // Prepare song info
        mNumWords =  song.rowLen * song.patternLen * (mLastRow + 1) * 2;

        // Create work buffer (initially cleared)
        mMixBuf = new Int32Array(mNumWords);
    };


    //--------------------------------------------------------------------------
    // Public methods
    //--------------------------------------------------------------------------

    // Generate audio data for a single track
    this.generate = function () {
        // Local variables
        var i, j, b, p, row, col, n, cp,
            k, t, lfor, e, x, rsample, rowStartSample, f, da;

        // Put performance critical items in local variables
        var chnBuf = new Int32Array(mNumWords),
            instr = mSong.songData[mCurrentCol],
            rowLen = mSong.rowLen,
            patternLen = mSong.patternLen;

        // Clear effect state
        var low = 0, band = 0, high;
        var lsample, filterActive = false;

        // Clear note cache.
        var noteCache = [];

         // Patterns
         for (p = 0; p <= mLastRow; ++p) {
            cp = instr.p[p];

            // Pattern rows
            for (row = 0; row < patternLen; ++row) {
                // Execute effect command.
                var cmdNo = cp ? instr.c[cp - 1].f[row] : 0;
                if (cmdNo) {
                    instr.i[cmdNo - 1] = instr.c[cp - 1].f[row + patternLen] || 0;

                    // Clear the note cache since the instrument has changed.
                    if (cmdNo < 16) {
                        noteCache = [];
                    }
                }

                // Put performance critical instrument properties in local variables
                var oscLFO = mOscillators[instr.i[15]],
                    lfoAmt = instr.i[16] / 512,
                    lfoFreq = Math.pow(2, instr.i[17] - 9) / rowLen,
                    fxLFO = instr.i[18],
                    fxFilter = instr.i[19],
                    fxFreq = instr.i[20] * 43.23529 * 3.141592 / 44100,
                    q = 1 - instr.i[21] / 255,
                    dist = instr.i[22] * 1e-5,
                    drive = instr.i[23] / 32,
                    panAmt = instr.i[24] / 512,
                    panFreq = 6.283184 * Math.pow(2, instr.i[25] - 9) / rowLen,
                    dlyAmt = instr.i[26] / 255,
                    dly = instr.i[27] * rowLen & ~1;  // Must be an even number

                // Calculate start sample number for this row in the pattern
                rowStartSample = (p * patternLen + row) * rowLen;

                // Generate notes for this pattern row
                for (col = 0; col < 4; ++col) {
                    n = cp ? instr.c[cp - 1].n[row + col * patternLen] : 0;
                    if (n) {
                        if (!noteCache[n]) {
                            noteCache[n] = createNote(instr, n, rowLen);
                        }

                        // Copy note from the note cache
                        var noteBuf = noteCache[n];
                        for (j = 0, i = rowStartSample * 2; j < noteBuf.length; j++, i += 2) {
                          chnBuf[i] += noteBuf[j];
                        }
                    }
                }

                // Perform effects for this pattern row
                for (j = 0; j < rowLen; j++) {
                    // Dry mono-sample
                    k = (rowStartSample + j) * 2;
                    rsample = chnBuf[k];

                    // We only do effects if we have some sound input
                    if (rsample || filterActive) {
                        // State variable filter
                        f = fxFreq;
                        if (fxLFO) {
                            f *= oscLFO(lfoFreq * k) * lfoAmt + 0.5;
                        }
                        f = 1.5 * Math.sin(f);
                        low += f * band;
                        high = q * (rsample - band) - low;
                        band += f * high;
                        rsample = fxFilter == 3 ? band : fxFilter == 1 ? high : low;

                        // Distortion
                        if (dist) {
                            rsample *= dist;
                            rsample = rsample < 1 ? rsample > -1 ? osc_sin(rsample*.25) : -1 : 1;
                            rsample /= dist;
                        }

                        // Drive
                        rsample *= drive;

                        // Is the filter active (i.e. still audiable)?
                        filterActive = rsample * rsample > 1e-5;

                        // Panning
                        t = Math.sin(panFreq * k) * panAmt + 0.5;
                        lsample = rsample * (1 - t);
                        rsample *= t;
                    } else {
                        lsample = 0;
                    }

                    // Delay is always done, since it does not need sound input
                    if (k >= dly) {
                        // Left channel = left + right[-p] * t
                        lsample += chnBuf[k-dly+1] * dlyAmt;

                        // Right channel = right + left[-p] * t
                        rsample += chnBuf[k-dly] * dlyAmt;
                    }

                    // Store in stereo channel buffer (needed for the delay effect)
                    chnBuf[k] = lsample | 0;
                    chnBuf[k+1] = rsample | 0;

                    // ...and add to stereo mix buffer
                    mMixBuf[k] += lsample | 0;
                    mMixBuf[k+1] += rsample | 0;
                }
            }
        }

        // Next iteration. Return progress (1.0 == done!).
        mCurrentCol++;
        return mCurrentCol / mSong.numChannels;
    };

    // Create a WAVE formatted Uint8Array from the generated audio data
    this.createWave = function() {
        // Create WAVE header
        var headerLen = 44;
        var l1 = headerLen + mNumWords * 2 - 8;
        var l2 = l1 - 36;
        var wave = new Uint8Array(headerLen + mNumWords * 2);
        wave.set(
            [82,73,70,70,
             l1 & 255,(l1 >> 8) & 255,(l1 >> 16) & 255,(l1 >> 24) & 255,
             87,65,86,69,102,109,116,32,16,0,0,0,1,0,2,0,
             68,172,0,0,16,177,2,0,4,0,16,0,100,97,116,97,
             l2 & 255,(l2 >> 8) & 255,(l2 >> 16) & 255,(l2 >> 24) & 255]
        );

        // Append actual wave data
        for (var i = 0, idx = headerLen; i < mNumWords; ++i) {
            // Note: We clamp here
            var y = mMixBuf[i];
            y = y < -32767 ? -32767 : (y > 32767 ? 32767 : y);
            wave[idx++] = y & 255;
            wave[idx++] = (y >> 8) & 255;
        }

        // Return the WAVE formatted typed array
        return wave;
    };

    this.getBuffer = function(){return mMixBuf};

    // Get n samples of wave data at time t [s]. Wave data in range [-2,2].
    this.getData = function(t, n) {
        var i = 2 * Math.floor(t * 44100);
        var d = new Array(n);
        for (var j = 0; j < 2*n; j += 1) {
            var k = i + j;
            d[j] = t > 0 && k < mMixBuf.length ? mMixBuf[k] / 32768 : 0;
        }
        return d;
    };
};


    // This music has been exported by SoundBox. You can use it with
    // http://sb.bitsnbites.eu/player-small.js in your own product.

    // See http://sb.bitsnbites.eu/demo.html for an example of how to
    // use it in a demo.

    // Song data
    var song = {
      songData: [
        { // Instrument 0
          i: [
          3, // OSC1_WAVEFORM
          138, // OSC1_VOL
          116, // OSC1_SEMI
          0, // OSC1_XENV
          0, // OSC2_WAVEFORM
          138, // OSC2_VOL
          128, // OSC2_SEMI
          4, // OSC2_DETUNE
          0, // OSC2_XENV
          0, // NOISE_VOL
          47, // ENV_ATTACK
          48, // ENV_SUSTAIN
          166, // ENV_RELEASE
          124, // ARP_CHORD
          3, // ARP_SPEED
          0, // LFO_WAVEFORM
          139, // LFO_AMT
          4, // LFO_FREQ
          1, // LFO_FX_FREQ
          3, // FX_FILTER
          64, // FX_FREQ
          160, // FX_RESONANCE
          3, // FX_DIST
          32, // FX_DRIVE
          147, // FX_PAN_AMT
          4, // FX_PAN_FREQ
          121, // FX_DELAY_AMT
          5 // FX_DELAY_TIME
          ],
          // Patterns
          p: [1,1,4,2,3],
          // Columns
          c: [
            {n: [111],
             f: []},
            {n: [114],
             f: []},
            {n: [113],
             f: []},
            {n: [112,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,113],
             f: []}
          ]
        },
      ],
      rowLen: 5513,   // In sample lengths
      patternLen: 32,  // Rows per pattern
      endPattern: 4,  // End pattern
      numChannels: 1  // Number of channels
    };

    // This music has been exported by SoundBox. You can use it with
    // http://sb.bitsnbites.eu/player-small.js in your own product.

    // See http://sb.bitsnbites.eu/demo.html for an example of how to
    // use it in a demo.

    // Song data
    var cellComplete = {
        songData: [
          { // Instrument 0
            i: [
            2, // OSC1_WAVEFORM
            138, // OSC1_VOL
            116, // OSC1_SEMI
            0, // OSC1_XENV
            2, // OSC2_WAVEFORM
            138, // OSC2_VOL
            128, // OSC2_SEMI
            4, // OSC2_DETUNE
            0, // OSC2_XENV
            0, // NOISE_VOL
            1, // ENV_ATTACK
            29, // ENV_SUSTAIN
            52, // ENV_RELEASE
            124, // ARP_CHORD
            3, // ARP_SPEED
            0, // LFO_WAVEFORM
            139, // LFO_AMT
            4, // LFO_FREQ
            1, // LFO_FX_FREQ
            3, // FX_FILTER
            64, // FX_FREQ
            160, // FX_RESONANCE
            3, // FX_DIST
            32, // FX_DRIVE
            147, // FX_PAN_AMT
            4, // FX_PAN_FREQ
            57, // FX_DELAY_AMT
            5 // FX_DELAY_TIME
            ],
            // Patterns
            p: [1],
            // Columns
            c: [
              {n: [147,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,150],
               f: []}
            ]
          },
          { // Instrument 1
            i: [
            2, // OSC1_WAVEFORM
            100, // OSC1_VOL
            128, // OSC1_SEMI
            0, // OSC1_XENV
            3, // OSC2_WAVEFORM
            201, // OSC2_VOL
            128, // OSC2_SEMI
            0, // OSC2_DETUNE
            0, // OSC2_XENV
            0, // NOISE_VOL
            5, // ENV_ATTACK
            6, // ENV_SUSTAIN
            58, // ENV_RELEASE
            0, // ARP_CHORD
            0, // ARP_SPEED
            0, // LFO_WAVEFORM
            195, // LFO_AMT
            6, // LFO_FREQ
            1, // LFO_FX_FREQ
            2, // FX_FILTER
            135, // FX_FREQ
            0, // FX_RESONANCE
            0, // FX_DIST
            32, // FX_DRIVE
            147, // FX_PAN_AMT
            6, // FX_PAN_FREQ
            121, // FX_DELAY_AMT
            6 // FX_DELAY_TIME
            ],
            // Patterns
            p: [1],
            // Columns
            c: [
              {n: [],
               f: []}
            ]
          },
        ],
        rowLen: 5513,   // In sample lengths
        patternLen: 32,  // Rows per pattern
        endPattern: 0,  // End pattern
        numChannels: 2  // Number of channels
      };
  
player = {
    type: "player",
    x: 0, 
    y: 0,
    width: 64,
    height: 64,
    xVel: 0,
    yVel: 0,
    xAcc: 0,
    yAcc: 0,
    drag: 10,
    speed: 0.05,

    draw: function(dt){
        actx = gamectx;
        actx.drawImage(spriteSheet.c, 0,0,100,100, this.x-viewX-this.width/2, this.y-viewY-this.height/2, 100, 100);
    },

    update: function(dt){
        if(Key.isDown(Key.a)){
            this.x -= this.speed;
        }else if(Key.isDown(Key.d)){
            this.x += this.speed;
        }
        if(Key.isDown(Key.w)){
            this.y -= this.speed;
        }else if(Key.isDown(Key.s)){
            this.y += this.speed;
        }
    }
}

function fr(x,y,w,h,fill='#F0F'){
    actx.fillStyle = fill;
    actx.fillRect(x, y, w, h);
}

function ln(x,y,x2,y2, thick=1, style="#F0F"){
    actx.beginPath();
    actx.moveTo(x,y);
    actx.lineTo(x2,y2);
    actx.lineWidth = thick;
    actx.strokeStyle = style;
    actx.stroke();
}

function fc(x, y, rx=4, ry=2, style="#FF0"){
    actx.fillStyle = style;
    actx.beginPath();
    actx.ellipse(x, y, rx, ry, 0, 0, Math.PI*2);
    actx.fill();
};

function noiseGradBox(x,y,w,h, fill0="#111", fill1="#FFF", size=1, type=0, amount=1000){
    ctx.fillStyle = fill0;
    ctx.fillRect(x, y, w, h);
    ctx.fillStyle = fill1;
    while(amount--){
        let px = Math.random()*w;
        let py = Math.random()*h;
        if(Math.random() < px/w){
            ctx.fillRect(x+px, y+py, 1, 1); 
        }
        
    }
}

function mC(w,h){
let c = document.createElement('canvas');
c.width = w; c.height= h;
return{c:c, ctx:c.getContext('2d')};
}

function drawBackground(){
    bg.ctx.fillStyle = '#181';
    bg.ctx.fillRect(0,0,worldWidth, worldHeight);
    actx = bg.ctx;
    for(let i = 0; i < 80000; i++){
    let x = prng.nextBoundedInt(0,worldWidth);
    let y = prng.nextBoundedInt(0,worldHeight);
    fc(x, y, 40, 20, 'rgba(10,50,0,0.05)');
  }
}

function drawPlayerSprite(){
    actx = spriteSheet.ctx;
    actx.translate(sprites.player.x, sprites.player.y);
    fc(50,50,40,40, 'white');
    actx.restore;
}

function drawObstacleSprite(){
    actx = spriteSheet.ctx;
    actx.save();
    actx.translate(sprites.obstacle.x, sprites.obstacle.y);
    fr(20,20,60,60,"#400");
    actx.restore();
}

function sprite(obj, x, y){
        actx.drawImage(spriteSheet.c, obj.x, obj.y, obj.width, obj.height, x, y, obj.width, obj.height );
}

//-----main.js---------------


states = {};

init = () => {
  
  //stats = new Stats();
  //stats.showPanel( 1 ); // 0: fps, 1: ms, 2: mb, 3+: custom
  //document.body.appendChild( stats.dom );

  audioCtx = new AudioContext;
  audioMaster = audioCtx.createGain();
  audioMaster.connect(audioCtx.destination);

  fps  = 60;
  tick = 1/fps;
  dt   = 0;
  start = elapsed = now = last = timeStamp();

  state = 'play';

  sounds = {};
  prng = new PRNG(1019);

  worldWidth = 10240;
  worldHeight = 10240;

  deadzoneX = 100;
  deadzoneY = 100;
  player.x = 400;
  player.y = 400;
  viewX = player.x-640/2;
  viewY = player.y-360/2;
  viewW = 640;
  viewH = 360;
  obstacleCount = 1000;
  bg = mC(worldWidth, worldHeight);
  spriteSheet = mC(1000, 1000);

  obstacles = [];
  createObstacles();

  c.width = 640; c.height = 360;
  c.style = 'width: 1280px; height: 720px';

  gamectx = c.getContext('2d');

  
  drawBackground();
  drawSprites();
  drawPlayerSprite();
  drawObstacleSprite();
  
  //change
  music = new CPlayer();
  music.init(song);
  done = false;
  
  soundsReady = 0;
  sndData = [
    {name:'song', data: song},
    {name:'cellComplete', data: cellComplete},
    ]
  //music stuff-----------------------------------------------------
      sndData.forEach(function(o){
          var sndGenerator = new CPlayer();
          sndGenerator.init(o.data);
          var done = false;
          setInterval(function () {
            if (done) {
              return;
            }
            done = sndGenerator.generate() == 1;
            if(done){
              let wave = sndGenerator.createWave().buffer;
              audioCtx.decodeAudioData(wave, function(buffer) {
                sounds[o.name] = buffer;
                soundsReady++;
                gameSong = playSound(sounds.song, 1, 0, 0.5, true);
              })
            }
          },0)
    })
    
  //FLAGS--------------------------------------------------------------
  paused = false;
  
   loop();

}

//initialize  event listeners--------------------------
window.addEventListener('keyup', function (event) {
  Key.onKeyup(event);
}, false);
window.addEventListener('keydown', function (event) {
  Key.onKeydown(event);
}, false);
window.addEventListener('blur', function (event) {
  paused = true;
}, false);
window.addEventListener('focus', function (event) {
  paused = false;
}, false);



loop = () => {
  //stats.begin();
   now = timeStamp();
   dt = dt + Math.min(1, (now - last) / 1000);
   elapsed = now - start;
   while(dt > tick) {
     dt = dt - tick;
     states[state].step(tick);
   }
   states[state].draw(dt);
   //stats.end();
  requestAnimationFrame(loop);
}

timeStamp = () => {
  if (window.performance && window.performance.now)
    return window.performance.now();
  else
    return new Date().getTime();
}

createObstacles = () => {

  for(let i = 0; i < obstacleCount; i++){
    obstacles.push({
      type: "obstacle",
      x: prng.nextBoundedInt(0, worldWidth),
      y: prng.nextBoundedInt(0, worldHeight),
      width: 40,
      height: 40
    })
  }
}

drawObstacles = () => {
  obstacles.forEach(function(el, i, arr){
    if(inView(el.x-viewX, el.y-viewH)){
      sprite(sprites.obstacle, el.x-viewX, el.y-viewY)
    }
  })
}

sprites = {
  player: {
    x: 0, y: 0, width: 100, height: 100
  },
  obstacle: {
    x: 100, y: 0, width: 80, height: 80
  }
}
//----- END main.js---------------


drawSprites = () => {

}
states.play = {
    draw: function(dt) {
        actx = gamectx;
        fr(0,0,c.width,c.height,'red');
        actx.drawImage(bg.c, viewX, viewY,640,360,0,0,640,360);
        
        //actx.drawImage(sprites, 100, 100);
        player.draw(dt);
        drawObstacles();
    },

    step: function(dt) {
        if(Key.justReleased(Key.r)){
            playSound(sounds.cellComplete, 1, 0, 0.5, false);
            Key.update();
          }
          player.update();
          if(player.x - viewX + deadzoneX > viewW){
            viewX = player.x - (viewW - deadzoneX)
          }
          else if(player.x - deadzoneX < viewX){
            viewX = player.x - deadzoneX
          }
          if(player.y - viewY + deadzoneY > viewH){
            viewY = player.y -(viewH - deadzoneY)
          }
          else if(player.y - deadzoneY < viewY){
            viewY = player.y - deadzoneY 
          }
    }
}
window.init();
})();
